<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>Babylon Template</title>

  <style>
  html, body {
    overflow: hidden;
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
  }

  #renderCanvas {
    width: 100%;
    height: 100%;
    touch-action: none;
  }
  </style>
  <!-- <script src="https://code.jquery.com/pep/0.4.1/pep.js"></script> -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/5.0.0/math.js"></script>
  <script src="https://cdn.babylonjs.com/cannon.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
  <script src="https://preview.babylonjs.com/cannon.js"></script>
  <script src="https://preview.babylonjs.com/Oimo.js"></script>
  <script src="https://preview.babylonjs.com/earcut.min.js"></script>
  <script src="https://preview.babylonjs.com/babylon.js"></script>
  <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
  <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
  <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
  <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
  <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
  <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
  <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
</head>

<body>
  <button id="add_sphere" style="position: absolute; right: 10px; top: 100px;">Add sphere</button>
  <button id="add_spring" style="position: absolute; right: 10px; top: 120px;">Add spring</button>


  <canvas id="renderCanvas" touch-action="none"></canvas> //touch-action="none" for best results from PEP

  <script>

  // Disable menu that pops up when ctrl is pressed on canvas
  $('body').on('contextmenu', '#renderCanvas', function(e){ return false; });

  var canvas = document.getElementById("renderCanvas"); // Get the canvas element
  var startingPoint;
  var currentMesh;

  // Stencil for highlight
  var engine = new BABYLON.Engine(canvas, true, { stencil: true }); // Generate the BABYLON 3D engine

  // window.addEventListener("click", function () {
  //   // We try to pick an object
  //   var pickResult = scene.pick(scene.pointerX, scene.pointerY);
  // })

  /******* Add the create scene function ******/

  var createScene = function () {

    // Create the scene space
    var scene = new BABYLON.Scene(engine);

    // Add a camera to the scene and attach it to the canvas
    var camera = new BABYLON.ArcRotateCamera("Camera", Math.PI / 2, Math.PI / 2, 20, BABYLON.Vector3.Zero(), scene);
    camera.attachControl(canvas, true, true);

    // Create highlight layer
    var hl = new BABYLON.HighlightLayer("hl1", scene);
    // hl.addMesh(sphere, BABYLON.Color3.Green());
    // hl.removeMesh(sphere);

    // Add lights to the scene
    var light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), scene);
    var light2 = new BABYLON.PointLight("light2", new BABYLON.Vector3(0, 1, -1), scene);

    var cylinderMat = new BABYLON.StandardMaterial("cylinder_mat", scene);
    cylinderMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
    cylinderMat.alpha = 0.25;

    // Ground
    var ground = BABYLON.Mesh.CreateGround("ground", 1000, 1000, 1, scene, false);
    // Ensure that ground doesn't get in the way of picking other meshes.
    ground.isPickable = false;
    var myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
    myMaterial.alpha = 0.0
    ground.material = myMaterial

    // No gravity please. :)
    scene.enablePhysics(new BABYLON.Vector3(0, 0, 0));

    // Slider https://www.babylonjs-playground.com/#U9AC0N#1
    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

    var panel = new BABYLON.GUI.StackPanel();
    panel.width = "220px";
    panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
    panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
    advancedTexture.addControl(panel);

    document.getElementById("add_sphere").addEventListener("click",function () {
      // Our built-in 'sphere' shape. Params: name, subdivs, size, scene
      var sphere = BABYLON.Mesh.CreateSphere("sphere", 16, 2, scene);
      sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1, restitution: 0.9, friction: 10}, scene);
      // Move the sphere upward 1/2 its height
      sphere.joints = [];
      bodies.push(sphere.physicsImpostor);
      sphere.position.y = 1;
    });

    document.getElementById("add_spring").addEventListener("click",function (){
      // First check if there are two bodies selected
      // Add cylinder and
      // Check that pickedMeshesInfo has two sphere elements

      if (pickedMeshesInfo.length == 2){
        // Add spring
        var header = new BABYLON.GUI.TextBlock();
        header.text = "Spring length: 8";
        header.height = "30px";
        header.color = "white";
        panel.addControl(header);

        var slider = new BABYLON.GUI.Slider();
        slider.minimum = 5;
        slider.maximum = 10;
        slider.value = 8;
        slider.height = "20px";
        slider.width = "200px";
        slider.onValueChangedObservable.add(function(value) {
          header.text = "Spring length: " + value.toFixed(2);
          if (joint) {
            joint.physicsJoint.restLength = value;
          }
        });
        panel.addControl(slider);

        var joint = new BABYLON.PhysicsJoint(BABYLON.PhysicsJoint.SpringJoint, {
          length: slider.value,
          stiffness: 10,
          damping: 0.5
        });

        joints.push(joint);
        mesh1 = pickedMeshesInfo[0];
        mesh2 = pickedMeshesInfo[1];
        mesh1.physicsImpostor.addJoint(mesh2.physicsImpostor, joint);

        // Create cylinder
        createCylinderForSpring(mesh1, mesh2, joint)
      }
      return
    });

    function createCylinderForSpring(mesh1, mesh2, joint) {
      var vstart = mesh1.position;
      var vend = mesh2.position;
      var distance = BABYLON.Vector3.Distance(vstart,vend);
      var cyl_diameter = 0.5; // Ultimately, make this reflect the strength of spring
      var number_of_sides = 36;
      var cylinder = new BABYLON.Mesh.CreateCylinder(
        "cylinder",
        distance,
        cyl_diameter,
        cyl_diameter,
        number_of_sides,
        scene,
        true); // Not sure how these arguements are assigned to the optional args of this function
      cylinder.material = cylinderMat;
      cylinder.start_mesh = mesh1;
      cylinder.end_mesh = mesh2;
      // This is to keep track of current orientation.
      cylinder.start_coord = cylinder.position.subtract(new BABYLON.Vector3(0, distance/2, 0));
      cylinder.end_coord = cylinder.position.add(new BABYLON.Vector3(0, distance/2, 0));
      cylinder.joint = joint;
      orientCylinder(cylinder);
    }

    function orientCylinder(cylinder) {
      var vstart = cylinder.start_mesh.position;
      var vend = cylinder.end_mesh.position;
      var v1 = vend.subtract(vstart);
      v1.normalize();

      var v2 = cylinder.end_coord.subtract(cylinder.start_coord)
      v2.normalize()
      // console.log(v2)
      // var v2 = new BABYLON.Vector3(0, 1, 0); // Axis this is created along
      // Using cross we will have a vector perpendicular to both vectors
      var axis = BABYLON.Vector3.Cross(v1, v2);
      axis.normalize();

      var angle = BABYLON.Vector3.Dot(v1, v2);

      // Then using axis rotation
      cylinder.rotationQuaternion = BABYLON.Quaternion.RotationAxis(axis, -Math.PI / 2 + angle);
      cylinder.position = cylinder.start_mesh.position.add(cylinder.end_mesh.position).scale(0.5)

      // Update cylinder end points
      cylinder.start_coord = cylinder.start_mesh.position
      cylinder.end_coord = cylinder.end_mesh.position
    }

    // https://www.babylonjs.com/demos/dragndrop/dragdrop.js
    var getGroundPosition = function (evt) {
      // Use a predicate to get position on the ground
      var pickinfo = scene.pick(scene.pointerX, scene.pointerY, function (mesh) { return mesh == ground; });
      if (pickinfo.hit) {
        return pickinfo.pickedPoint;
      }

      return null;
    }

    var pickedMeshesInfo = [];
    var onPointerDown = function (evt) {
      if (evt.button !== 0) {
        return;
      }
      if (event.ctrlKey) {
        // Remove Meshes from highlight layer
        for (var i = 0; i < pickedMeshesInfo.length; i++) {
          hl.removeMesh(pickedMeshesInfo[i]);
        }
        pickedMeshesInfo.length = 0;
      }

      // http://www.babylonjs-playground.com/#SWSKU#6
      if (event.altKey) {
        // check if we are under a mesh
        var pickInfo = scene.pick(scene.pointerX, scene.pointerY);
        if (pickInfo.hit) {
          pickedMeshesInfo.push(pickInfo.pickedMesh);
          // Add mesh to highlight layer
          hl.addMesh(pickInfo.pickedMesh, BABYLON.Color3.Green());
          startingPoint = getGroundPosition();

          if (startingPoint) { // we need to disconnect camera from canvas
            setTimeout(function () {
              camera.detachControl(canvas);
            }, 0);
          }
        }
      }
      else{

        // check if we are under a mesh
        var pickInfo = scene.pick(scene.pointerX, scene.pointerY, function (mesh) { return mesh !== ground; });
        if (pickInfo.hit) {
          currentMesh = pickInfo.pickedMesh;
          startingPoint = getGroundPosition(evt);

          if (startingPoint) { // we need to disconnect camera from canvas
            setTimeout(function () {
              camera.detachControl(canvas);
            }, 0);
          }
        }
      }}

      var onPointerUp = function () {
        if (startingPoint) {
          camera.attachControl(canvas);
          startingPoint = null;
          return;
        }
      }

      var onPointerMove = function (evt) {
        if (!startingPoint) {
          return;
        }

        var current = getGroundPosition(evt);

        if (!current) {
          return;
        }

        var diff = current.subtract(startingPoint);

        if (pickedMeshesInfo.length > 0) {
          for (var i = 0; i < pickedMeshesInfo.length; i++) {
            pickedMeshesInfo[i].position.addInPlace(diff);
            //currentMesh.isPickable = false;
            startingPoint = current;
          }
        }
        else{
          currentMesh.position.addInPlace(diff);
          startingPoint = current;
        }
        // currentMesh.position.addInPlace(diff);
        // startingPoint = current;

      }

      canvas.addEventListener("pointerdown", onPointerDown, false);
      canvas.addEventListener("pointerup", onPointerUp, false);
      canvas.addEventListener("pointermove", onPointerMove, false);

      scene.onDispose = function () {
        canvas.removeEventListener("pointerdown", onPointerDown);
        canvas.removeEventListener("pointerup", onPointerUp);
        canvas.removeEventListener("pointermove", onPointerMove);
      }

      // Add friction
      // http://www.babylonjs-playground.com/#OJVVA#3
      // Need to add more things to this list.
      var bodies = [];
      var cylinders = [];
      var joints = [];
      var timer = 0;
      scene.registerBeforeRender(function () {
        // Add function to update all cylinders for springs.
        bodies.forEach(function (b) {
          var objVelocity = b.getLinearVelocity()
          var velocityVector = Object.keys(objVelocity).map(function(key) {return objVelocity[key];});
          if (math.norm(velocityVector) > 0.0) {
            // console.log(math.norm(velocityVector))
            var frictionStrength = 1.05
            b.setLinearVelocity(new BABYLON.Vector3(b.getLinearVelocity().x / frictionStrength,
            b.getLinearVelocity().y / frictionStrength,
            b.getLinearVelocity().z / frictionStrength));
            // console.log(b.getLinearVelocity())
          }
        });
      });

      return scene;
    };

    /******* End of the create scene function ******/

    var scene = createScene(); //Call the createScene function

    engine.runRenderLoop(function () { // Register a render loop to repeatedly render the scene
      scene.render();
    });

    window.addEventListener("resize", function () { // Watch for browser/canvas resize events
      engine.resize();
    });
    </script>

  </body>

  </html>
