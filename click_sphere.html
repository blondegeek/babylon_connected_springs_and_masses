<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>Babylon Template</title>

  <style>
  html, body {
    overflow: hidden;
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
  }

  #renderCanvas {
    width: 100%;
    height: 100%;
    touch-action: none;
  }
  </style>
  <!-- <script src="https://code.jquery.com/pep/0.4.1/pep.js"></script> -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/5.0.0/math.js"></script>
  <script src="https://cdn.babylonjs.com/cannon.js"></script>
  <!-- <script src="https://preview.babylonjs.com/cannon.js"></script> -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>

<body>
  <button id="button" style="position: absolute; right: 10px; top: 100px;">Click Me!</button>

  <canvas id="renderCanvas" touch-action="none"></canvas> //touch-action="none" for best results from PEP

  <script>

  var canvas = document.getElementById("renderCanvas"); // Get the canvas element
  var startingPoint;
  var currentMesh;

  // Stencil for highlight
  var engine = new BABYLON.Engine(canvas, true, { stencil: true }); // Generate the BABYLON 3D engine

  // window.addEventListener("click", function () {
  //   // We try to pick an object
  //   var pickResult = scene.pick(scene.pointerX, scene.pointerY);
  // })

  /******* Add the create scene function ******/

  var createScene = function () {

    // Create the scene space
    var scene = new BABYLON.Scene(engine);

    // Add a camera to the scene and attach it to the canvas
    var camera = new BABYLON.ArcRotateCamera("Camera", Math.PI / 2, Math.PI / 2, 2, BABYLON.Vector3.Zero(), scene);
    camera.attachControl(canvas, true);

    // Add lights to the scene
    var light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), scene);
    var light2 = new BABYLON.PointLight("light2", new BABYLON.Vector3(0, 1, -1), scene);

    // Ground
    var ground = BABYLON.Mesh.CreateGround("ground", 1000, 1000, 1, scene, false);
    var myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
    myMaterial.alpha = 0.0
    ground.material = myMaterial

    // Add and manipulate meshes in the scene
    var sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter:2}, scene);
    var sphere2 = BABYLON.MeshBuilder.CreateSphere("sphere2", {diameter:1}, scene);

    // No gravity please. :)
    scene.enablePhysics(new BABYLON.Vector3(0, 0, 0));
    sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor,
      { mass: 1, restitution: 0.9, friction: 10},
      scene);
    sphere2.physicsImpostor = new BABYLON.PhysicsImpostor(sphere2, BABYLON.PhysicsImpostor.SphereImpostor,
      { mass: 0.5, restitution: 0.9, friction: 10},
      scene);

    var springJoing = new BABYLON.PhysicsJoint(BABYLON.PhysicsJoint.SpringJoint, {
      length: 8,
      stiffness: 10,
      damping: 0.5
    });
    sphere.physicsImpostor.addJoint(sphere2.physicsImpostor, springJoing);
    sphere.position.y = 10;

    document.getElementById("button").addEventListener("click",function () {
      // Our built-in 'sphere' shape. Params: name, subdivs, size, scene
      var sphere = BABYLON.Mesh.CreateSphere("sphere1", 16, 2, scene);
      // Move the sphere upward 1/2 its height
      sphere.position.y = 1;
    });

    // https://www.babylonjs.com/demos/dragndrop/dragdrop.js
    var getGroundPosition = function (evt) {
      // Use a predicate to get position on the ground
      var pickinfo = scene.pick(scene.pointerX, scene.pointerY, function (mesh) { return mesh == ground; });
      if (pickinfo.hit) {
        return pickinfo.pickedPoint;
      }

      return null;
    }

    var onPointerDown = function (evt) {
      if (evt.button !== 0) {
        return;
      }

      // check if we are under a mesh
      var pickInfo = scene.pick(scene.pointerX, scene.pointerY, function (mesh) { return mesh !== ground; });
      if (pickInfo.hit) {
        currentMesh = pickInfo.pickedMesh;
        startingPoint = getGroundPosition(evt);

        if (startingPoint) { // we need to disconnect camera from canvas
          setTimeout(function () {
            camera.detachControl(canvas);
          }, 0);
        }
      }
    }

    var onPointerUp = function () {
      if (startingPoint) {
        camera.attachControl(canvas);
        startingPoint = null;
        return;
      }
    }

    var onPointerMove = function (evt) {
      if (!startingPoint) {
        return;
      }

      var current = getGroundPosition(evt);

      if (!current) {
        return;
      }

      var diff = current.subtract(startingPoint);
      currentMesh.position.addInPlace(diff);

      startingPoint = current;

    }

    canvas.addEventListener("pointerdown", onPointerDown, false);
    canvas.addEventListener("pointerup", onPointerUp, false);
    canvas.addEventListener("pointermove", onPointerMove, false);

    scene.onDispose = function () {
      canvas.removeEventListener("pointerdown", onPointerDown);
      canvas.removeEventListener("pointerup", onPointerUp);
      canvas.removeEventListener("pointermove", onPointerMove);
    }

    // Add friction
    // http://www.babylonjs-playground.com/#OJVVA#3
    var bodies = [sphere.physicsImpostor, sphere2.physicsImpostor];
    var timer = 0;
    scene.registerBeforeRender(function () {
      bodies.forEach(function (b) {
        var objVelocity = b.getLinearVelocity()
        var velocityVector = Object.keys(objVelocity).map(function(key) {return objVelocity[key];});
        if (math.norm(velocityVector) > 0.0) {
          // console.log(math.norm(velocityVector))
          var frictionStrength = 1.05
          b.setLinearVelocity(new BABYLON.Vector3(b.getLinearVelocity().x / frictionStrength,
                                                  b.getLinearVelocity().y / frictionStrength,
                                                  b.getLinearVelocity().z / frictionStrength));
          // console.log(b.getLinearVelocity())
        }
      });
    });

    return scene;
  };

  /******* End of the create scene function ******/

  var scene = createScene(); //Call the createScene function

  engine.runRenderLoop(function () { // Register a render loop to repeatedly render the scene
    scene.render();
  });


  window.addEventListener("resize", function () { // Watch for browser/canvas resize events
    engine.resize();
  });
  </script>

</body>

</html>
